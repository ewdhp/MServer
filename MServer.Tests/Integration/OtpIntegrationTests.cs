using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Xunit;
using MServer.Services;
using OtpNet;
using Microsoft.Extensions.Configuration;

namespace MServer.Tests.Integration
{
    /// <summary>
    /// Integration tests that verify the complete OTP functionality including 
    /// QR code generation, secret encryption/decryption, and phone validation simulation
    /// </summary>
    public class OtpIntegrationTests
    {
        [Fact]
        public async Task CompleteOtpWorkflow_ShouldWork()
        {
            // This test simulates the complete workflow:
            // 1. Generate QR code and secret
            // 2. Store secret securely (encrypted)
            // 3. Simulate phone scanning QR code
            // 4. Validate codes from "phone"

            var totpService = CreateTotpService();

            // Step 1: Generate new TOTP secret (this would be shown as QR code)
            var encryptedSecret = totpService.GenerateNewSecret();
            var accountName = "user@example.com";
            var qrUri = totpService.GetProvisioningUri(encryptedSecret, accountName);

            // Verify QR URI format
            Assert.StartsWith("otpauth://totp/", qrUri);
            Assert.Contains(Uri.EscapeDataString(accountName), qrUri);
            Assert.Contains("secret=", qrUri);

            // Step 2: Extract the plain secret from QR URI to simulate phone scanning
            var uri = new Uri(qrUri);
            var queryParams = uri.Query.TrimStart('?').Split('&')
                    .Select(param => param.Split('='))
                    .Where(parts => parts.Length == 2)
                    .ToDictionary(parts => parts[0], parts => Uri.UnescapeDataString(parts[1]));
                queryParams.TryGetValue("secret", out var plainSecret);
            Assert.NotNull(plainSecret);
            Assert.NotEmpty(plainSecret);

            // Step 3: Create TOTP generator for "phone" using the plain secret
            var phoneSecretBytes = Base32Encoding.ToBytes(plainSecret);
            var phoneTotp = new Totp(phoneSecretBytes);

            // Step 4: Generate code on "phone" and verify with server
            var phoneGeneratedCode = phoneTotp.ComputeTotp();
            var isValidOnServer = totpService.VerifyCode(encryptedSecret, phoneGeneratedCode);

            Assert.True(isValidOnServer, "Code generated by phone should be valid on server");

            // Step 5: Test with invalid code
            var invalidCode = "000000";
            var isInvalidCodeAccepted = totpService.VerifyCode(encryptedSecret, invalidCode);
            Assert.False(isInvalidCodeAccepted, "Invalid code should not be accepted");

            // Step 6: Verify server can also generate same code (for testing purposes)
            var serverGeneratedCode = totpService.GenerateCode(encryptedSecret);
            Assert.Equal(phoneGeneratedCode, serverGeneratedCode);
        }

        [Fact]
        public void TimeBasedCodeGeneration_ShouldChangeOverTime()
        {
            // This test verifies that TOTP codes change over time
            var totpService = CreateTotpService();
            var encryptedSecret = totpService.GenerateNewSecret();

            // Generate initial code
            var initialCode = totpService.GenerateCode(encryptedSecret);
            
            // Wait for next time step (in real scenario, wait 30 seconds)
            // For testing, we can't easily simulate time passage, 
            // but we can verify the code format and that it's deterministic
            var secondCode = totpService.GenerateCode(encryptedSecret);
            
            // In the same 30-second window, codes should be identical
            Assert.Equal(initialCode, secondCode);
            
            // Verify code format
            Assert.Equal(6, initialCode.Length);
            Assert.True(int.TryParse(initialCode, out _));
        }

        [Fact]
        public void SecretEncryption_ShouldBeSecure()
        {
            var totpService = CreateTotpService();

            // Generate multiple secrets
            var secret1 = totpService.GenerateNewSecret();
            var secret2 = totpService.GenerateNewSecret();

            // Each secret should be different (encrypted differently)
            Assert.NotEqual(secret1, secret2);

            // Each secret should be base64 encoded (encrypted format)
            Assert.True(IsBase64String(secret1));
            Assert.True(IsBase64String(secret2));

            // Codes generated from different secrets should be different (most of the time)
            var code1 = totpService.GenerateCode(secret1);
            var code2 = totpService.GenerateCode(secret2);
            
            // While there's a tiny chance codes could be same, it's extremely unlikely
            // This test mainly verifies that the system can handle multiple secrets
            Assert.NotNull(code1);
            Assert.NotNull(code2);
        }

        [Fact]
        public async Task MultipleAccounts_ShouldWorkIndependently()
        {
            var totpService = CreateTotpService();

            // Create multiple accounts
            var accounts = new[]
            {
                ("alice@example.com", totpService.GenerateNewSecret()),
                ("bob@example.com", totpService.GenerateNewSecret()),
                ("charlie@example.com", totpService.GenerateNewSecret())
            };

            // Generate QR codes for each
            var qrCodes = new string[accounts.Length];
            for (int i = 0; i < accounts.Length; i++)
            {
                qrCodes[i] = totpService.GetProvisioningUri(accounts[i].Item2, accounts[i].Item1);
                Assert.StartsWith("otpauth://totp/", qrCodes[i]);
                Assert.Contains(Uri.EscapeDataString(accounts[i].Item1), qrCodes[i]);
            }

            // Each account should have different QR codes
            for (int i = 0; i < qrCodes.Length; i++)
            {
                for (int j = i + 1; j < qrCodes.Length; j++)
                {
                    Assert.NotEqual(qrCodes[i], qrCodes[j]);
                }
            }

            // Generate and verify codes for each account
            foreach (var (accountName, encryptedSecret) in accounts)
            {
                var code = totpService.GenerateCode(encryptedSecret);
                var isValid = totpService.VerifyCode(encryptedSecret, code);
                Assert.True(isValid, $"Code should be valid for account {accountName}");

                // Verify that code from one account doesn't work for another
                foreach (var (otherAccount, otherSecret) in accounts)
                {
                    if (otherAccount != accountName)
                    {
                        var isValidForOther = totpService.VerifyCode(otherSecret, code);
                        // This might occasionally be true by coincidence, but usually false
                        // The main point is that the system correctly handles multiple accounts
                    }
                }
            }
        }

        [Fact]
        public void ErrorHandling_ShouldBeRobust()
        {
            var totpService = CreateTotpService();

            // Test with invalid encrypted secrets
            Assert.Throws<InvalidOperationException>(() => 
                totpService.GenerateCode("invalid-secret"));

            Assert.False(totpService.VerifyCode("invalid-secret", "123456"));

            // Test with null/empty values - this should throw an exception when trying to decrypt empty string
            Assert.ThrowsAny<Exception>(() => 
                totpService.GetProvisioningUri("", "test@example.com"));
        }

        [Theory]
        [InlineData("user@example.com", "MyApp")]
        [InlineData("test.user+tag@domain.co.uk", "My Secure App")]
        [InlineData("user with spaces@example.com", "App (Production)")]
        public void QrCodeGeneration_ShouldHandleSpecialCharacters(string accountName, string issuer)
        {
            var totpService = CreateTotpService();
            var encryptedSecret = totpService.GenerateNewSecret();

            // Should not throw exception with special characters
            var qrUri = totpService.GetProvisioningUri(encryptedSecret, accountName, issuer);

            Assert.StartsWith("otpauth://totp/", qrUri);
            Assert.Contains("secret=", qrUri);
            Assert.Contains("issuer=", qrUri);
            Assert.Contains(Uri.EscapeDataString(accountName), qrUri);
            
            // URI should be valid
            Assert.True(Uri.TryCreate(qrUri, UriKind.Absolute, out _));
        }

        private TotpService CreateTotpService()
        {
            var inMemorySettings = new Dictionary<string, string?>
            {
                {"Security:EncryptionKey", "TestEncryptionKey123456789TestEncryptionKey123456789"}
            };
            
            var configuration = new Microsoft.Extensions.Configuration.ConfigurationBuilder()
                .AddInMemoryCollection(inMemorySettings)
                .Build();

            return new TotpService(configuration);
        }

        private bool IsBase64String(string str)
        {
            try
            {
                Convert.FromBase64String(str);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}